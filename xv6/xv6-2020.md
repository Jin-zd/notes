## Lab4 Traps
### 1 RISC-V assembly
1.a0-a7 用于保存函数的参数，13保存在 a2 中。
2.没有调用，函数 f 和 g 直接被内联优化了。
![[1.png|300]]

3.0x640。
![[2.png|300]]
4.ra保存的是函数调用后返回的地址，为0x38。
![[Pasted image 20241210171142.png|400]]
5.He110 World.
6.y 的输出结果为 0，保存的是 a2 寄存器中的值。

### 2 Backtrace
该题目的目的为实现 `backtrace` 函数，以打印当前进程的调用链。
首先，在 `kernel/riscv.h` 文件中添加读取栈帧指针的函数，执行 `mv %0, s0` 将 `s0` 寄存器的值读出，`s0` 寄存器用于存放帧指针：
![[Pasted image 20241210180746.png|300]]
然后，在 `kernel/printf.c` 中添加 `backtrace` 函数。该函数首先调用 `r_fp` 获取栈帧指针的首地址，向上对齐获得栈顶帧指针之后，在循环中打印，`return address` 是当前 `fp - 8`，调用该函数的栈帧是 `fp - 16`：
![[Pasted image 20241210181130.png|400]]
之后，在 `kernel/defs.h` 添加 `backtrace` 的声明，在 `kernel/syspro.c` 的 `sys_sleep` 函数和 `kernel/printf.c` 的 `panic` 函数中添加 对 `backtrace` 的调用即可。

### 3 Alarm
该题的目的是让我们增加系统调用，该系统调用会在指定时间间隔后调用用户态的函数。
首先，在 `kernel/proc.h` 的 `proc` 结构体中添加，`ticks` 用来保存定时器的周期，`alarmhandler`用来存储定时器处理函数的地址，`tickspass` 用于表明定时器状态，`accessable` 用于表明是否在进行信号处理，`alarmtrapframe` 用于保存原有的上下文：
![[Pasted image 20241210183759.png|300]]
接着，在 `kernel/proc.c` 中添加分配和回收 `alarmtrapframe` 的代码。
分配和初始化：
![[Pasted image 20241210183908.png|500]]
回收：
![[Pasted image 20241210183938.png|300]]
然后，在 kernel/syscall.h 中添加调用号：
![[Pasted image 20241210184119.png|200]]
在 kernel/syscall.c 中添加系统调用映射：
![[Pasted image 20241210184139.png|300]]
![[Pasted image 20241210184153.png|250]]
然后，在 `kernel/sysproc.c` 中添加系统调用，其中，`sys_sigalarm` 为当前进程设置一个定时器，该定时器会在每次经过指定的 `ticks` 数量后触发，并调用用户程序提供的 `alarmhandler` 函数作为处理程序：
![[Pasted image 20241210184358.png|400]]
`sys_return` 用于恢复信号处理后的进程状态，并恢复到进程在处理信号之前的执行状态。首先判断信号处理是否已经完成并且可以恢复状态，如果可以恢复，`memmove` 函数将 `p->alarmtrapframe` 中保存的进程状态恢复到 `p->trapframe` 中，并将信号处理标志位置为可以处理：
![[Pasted image 20241210184429.png|500]]
然后，在 `kernel/trap.c` 的 `usertrap` 函数中，每当定时器中断触发时，进程的 `tickspass` 计数器增加 1，如果 `p->ticks` 不为 0 且 `tickspass` 达到指定的周期（即 `tickspass == p->ticks`），则表示定时器触发了，应该执行定时器处理逻辑，此时，将 `tickspass` 计数器重置为 0，准备下一个周期的计数，接着检查进程是否可以访问其上下文（`p->accessable==1`），如果可以，则保存当前进程的上下文到 `p->alarmtrapframe` 中，再将进程的 `trapframe` 中的 pc (`epc`) 设置为 `alarmhandler` 的地址，即定时器触发时将跳转到用户程序提供的定时器处理函数，最后将 `accessable` 设置为 0，表示信号处理程序不可重复访问，防止在信号处理期间再次修改上下文：
![[Pasted image 20241210184540.png|500]]
最后，在 `user/user.h` 和 `user/usys.pl` 中添加系统调用声明和入口即可：
![[Pasted image 20241210184647.png|400]]
![[Pasted image 20241210184705.png|200]]

### 4 Test
`make grade` 可以通过全部测试：
![[Pasted image 20241210184940.png|400]]



## Lab5 Lazy allocation

该次实验是为了在 xv6 中实现惰性分配，即给进程分配内存的时候，只先改变指针地址，并不分配物理内存，只有当使用这块内存时才引发缺页异常重新分配内存。
### 1 Eliminate allocation from sbrk()
`kernel/sysproc.c`  中，从 `sbrk()` 系统调用中将页面分配的功能删除，即删除进程空间增长的调用，只是将进程的大小增加 n 并返回旧大小，这里同时处理了 `n < 0`  的情况，参照 `growproc()`：
![[Pasted image 20241218220157.png|400]]

### 2 Lazy allocation
`kernel/trap.c` 中，在 `usertrap()` 函数中添加对缺页异常的处理。首先通过 `r_stval()` 返回发生缺页异常的虚拟地址，接着检查该虚拟地址是否在进程的有效地址空间范围内，若超出了，进程将被标记为 `killed`，否则分配一页物理内存（调用`kalloc()`分配），并返回指向该物理内存的指针`pa`，初始化分配的页，并将该物理页面 `pa` 映射到虚拟地址 `va`，完成页面的分配。
![[Pasted image 20241218220520.png]]

### 3 Lazytests and Usertests
如果 `sbrk` 增加 `p->sz` 后直到释放进程都没有真正使用某些地址，那么这些地址就不会分配到内存，以及在页表中添加映射。但 `uvmunmap()` 会根据 `p->sz` 来在页表中取消映射；`fork` 时会使用的`uvmcopy()` 会根据 `p->sz` 来照搬父进程的页表给子进程。故修改 `kernel/vm.c` 中的 `uvmunmap()`，`uvmcopy()` 函数，遇到未映射的页时直接直接 `continue`：
![[Pasted image 20241218221156.png|400]]
处理进程将有效地址从 `sbrk()` 传递给系统调用（read or write），但尚未分配该地址的内存的情况，和 `usertrap()` 中处理缺页异常一致，将类似过程写入 `kernel/vm.c` 中的 `walkaddr()` 函数中即可：
![[Pasted image 20241218221659.png]]
### 4 Test
`make grade` 可以通过全部测试：
![[Pasted image 20241218222111.png|200]]
![[Pasted image 20241218222211.png|200]]
![[Pasted image 20241218222245.png|200]]

## Lab6 Copy on-write

该次实验目的是设计`copy-on-write fork()`，以延迟为子进程分配和复制物理内存页面，直到实际需要。
### 1 Implement copy-on write
首先，在 `kernel/riscv.h` 中给页表添加新的标志位，代表这个页是否是写时复制页，称为`PTE_COW`，使用保留位：
![[Pasted image 20241221104353.png|500]]
接着，写时复制是写的时候才复制父进程的物理页给子进程，所以在 `kernel/vm.c` 的 `uvmcopy()` 函数中，去除复制内存的代码，清除父进程中所有`PTE` 的 `PTE_W` 位，并且设置 `PTE_COW` 位（如果该页本身不是只读的），并将父进程映射的物理页直接映射到子进程中，权限保持和父进程一致，调用 `krefpage()`增加页的引用计数：
![[Pasted image 20241221104846.png|400]]
引用计数是为了避免内存泄漏，当多个进程映射同一个物理页的时候，只记录该物理页的引用数，调用`kfree`释放物理页的时候，只对引用数减一，当引用数为 0 时，释放物理页。
然后，在`kernrl/trap.c`中的函数`usertrap()`中添加对页面错误的检测，如果当前访问的地址符合`COW`页的条件，进行进程复制内存操作：
![[Pasted image 20241221105555.png|600]]
其中，通过调用`r_scause`判断是否是页面错误，实现`uvmcheckcowpage()`函数判断是否是`COW`导致的页面错误，符合这些条件，调用实现的`uvmcowcopy()`函数执行写时复制操作。
`kernel/vm.c`中的`uvmcheckcowpage()`函数如下，判断地址是否进程内存范围内、地址是否有映射、地址是否有效且是`COW`页：
![[Pasted image 20241221105750.png|300]]
`kernel/vm.c`中的`uvmcowcopy()`函数如下，先获取虚拟地址的页表项、映射的物理地址、新分配的物理页，再修改新的映射，若当前页有`COW`标识，权限修改为可写，清除`COW`标识，最后清除旧的映射，建立新的映射：
![[Pasted image 20241221105957.png|400]]
其中，`kcopy_n_deref()`函数功能是，当有进程通过`COW`复制新的物理页时，将原本物理页的引用数-1，返回新创建的物理页地址。若原本的物理页引用数为1，直接使用该物理页。
`kernel/vm.c`中的`copyout()`函数中，检测复制的页是否是`COW`页，若是，执行复制操作：
![[Pasted image 20241221110711.png|250]]
最后，处理内存分配回收时的操作。在`kernel/kalloc.c`中定义宏，分别用于由物理地址获取物理页id、获取物理页数上限、获取地址对应物理页引用数：
![[Pasted image 20241221110925.png|400]]
再定义每个物理页的引用数数组和用于该数组的锁，防止竞态引起内存泄漏：
![[Pasted image 20241221111040.png|250]]
在 `kinit()`函数中进行锁的初始化：
![[Pasted image 20241221111301.png|250]]
在 `kfree()`函数中，仅当页面的引用数等于 0 时释放页面：
![[Pasted image 20241221111430.png|500]]
修改 `kalloc()`函数，将新分配的物理页的引用数设置为1：
![[Pasted image 20241221111828.png|400]]
实现`krefpage()`，用于增加页的引用数：
![[Pasted image 20241221111934.png|200]]
实现`kcopy_n_deref()`，用于返回对应的物理页，当前物理页的引用数为1，无需分配新的物理页，否则分配新的物理页，并把旧页中的数据复制到新页，再将旧页引用数减一：
![[Pasted image 20241221112056.png|300]]
### 2 Test
`make grade` 可以通过全部测试：
![[Pasted image 20241221104702.png|400]]

## Lab7 Multithreading
该实验要求实现⽤户级线程、优化并发程序，使用线程提速程序，实现同步屏障。
### 1 Uthread: switching between threads
该任务要求实现创建线程和保存/恢复寄存器以在线程之间切换的功能。
首先，仿照 `swtch.S` 实现 `uthread_switch.S`，完成上下文切换，保存当前线程寄存器，读取新线程的的寄存器：
![[Pasted image 20241221114617.png|200]]
在 `user/uthread.c`中，给线程增加`context`结构体，用于保存线程上下文，并在线程结构体中加入`context`结构体：
![[Pasted image 20241221114808.png|100]]
![[Pasted image 20241221114829.png|400]]
在调度函数`thread_schedule`中加入线程切换函数`thread_switch`：
![[Pasted image 20241221114939.png|500]]

在线程创建函数`thread_create()`中，分别设置返回地址`pa`和栈指针`sp`： 
![[Pasted image 20241221115038.png|400]]
### 2 Using threads
该任务要求实现线程安全访问，需在并发写共享数据的地方加锁。
首先，在 `notxv6/ph.c`声明线程锁，给每一个散列桶声明一个锁：
![[Pasted image 20241221115440.png|300]]
在 `main()`中初始化锁：
​![[Pasted image 20241221115524.png|300]]
在执行`put`操作的时候，针对散列桶上锁：
![[Pasted image 20241221115616.png|300]]
### 3 Barrier
该任务要求实现屏障。
线程调用`barrier`之后，`bstate`中的线程数`nthread`应该增一，判断当前进入屏障的线程数是否达到全局的`nthread`。若未达到，调用`pthread_cond_wait`，让当前线程睡眠，等待线程数达到要求；若达到了，将`bstate`中的轮数`round`增一、清空`bstate`的线程数并唤醒其他正在睡眠的线程，据此可以完成 `barrier()`：
![[Pasted image 20241221115817.png|400]]
### 4 Test
`make grade` 可以通过全部测试：
![[Pasted image 20241221114512.png|400]]


